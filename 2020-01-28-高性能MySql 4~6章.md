---
title: '高性能MySql 4~6章'
date: '2020-01-28 00:00:00'
thumbnail: https://i.loli.net/2020/01/31/x7tbhdX8uR5nLp2.jpg
tags:
    - 代码
categories:
    - 架构
    - mysql
---

#### 第四章 Schema设计

####  选择优化的数据类型
更小的通常更好，但是要确保没有低估需要存储的值的范围，因为在schema中的多个地方增加数据类型范围是一个十分耗时的操作。

##### 简单就好
简单的数据类型的操作通常需要更少的cpu时间。

##### 尽量避免NULL
可为NULL的列使得索引、索引比统计和值比较都更为复杂。

当然也有例外，InnoDB使用单独的位存储NULL值， 所以对于稀疏数据有很好的空间效率。

##### 选择标识符
一旦选定一种类型，要确保在所有的关联表中都使用同样的类型。类型之间需要精确匹配，包括像UNSIGNED这样的属性。尽量只用整型定义标识符。

##### 注意可变长字符串
其在临时表和排序时可能导致悲观的按最大长度分配内存

##### 范式与反范式
范式是好的，但是反范式有时也是必须的，并且能带来好处。

#### 第五章 创建高性能索引

##### B-Tree 索引的查询类型
 - 全值匹配： 指的是和索引的所有列进行匹配
 - 匹配最左前缀： 查找索引前几列进行匹配
 - 匹配列前缀: 只匹配某一列的值的开头部分
 - 匹配范围值： 查找索引某一范围的值
 - 精确匹配某一列并范围匹配另外一列
 - 只访问索引的查询：覆盖索引

 ##### B-Tree 索引的限制
 - 如果不是按照索引的最左列开始查找，则无法使用索引
 - 不能跳过索引中的列
 - 如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引：
   
   例如查询 索引为key(last_name, fisrt_name, dob)
   ```
      where last_name = 'a' and first_name like 'J%' and dob = '1877-12-23'
   ```
   
##### 索引的优点
1. 大大减少服务器需要扫描的数据量
2. 帮助服务器避免排序和临时表
3. 将随机I/O变为顺序I/O

##### 高性能索引-独立的列
如果查询中列不是独立的，则mysql不会使用索引
```
 select actor_id from sakila.actor where actor_id + 1 = 5;

```

##### 高性能索引-前缀索引和索引选择性
有时候需要索引很长的字符列，通常可以索引开始部分的字符，同时也会降低索引的选择性。

索引的选择性指的是，不重复的索引值和数据表的记录总数的比值。索引的选择性越高表示查询效率越高，因为选择性高的索引可以过滤掉更多的行。

前缀索引是一种能使索引更小，更快的有效方法，但是也有其缺点：前缀索引无法做order by 和 group by，也无法使用前缀索引做覆盖索引。

##### 高性能索引-多列索引

最容易遇到的困惑是多列索引的顺序，正确的顺序依赖于使用索引的查询，同时需要考虑如何更好的满足排序和分组需要。对于如何选择索引的列顺序有一个经验法则：将选择性最高的列放在索引的最前列。**只有不需要考虑排序和分组时**，将选择性跟高的列放在最前面通常是最好的，但是考虑问题需要更全面，避免随机I/O和排序更加重要。

##### 高性能索引-覆盖索引

如果一个索引包含所需要查询的字段的值，我们就可以称之为“覆盖索引”

覆盖索引的好处：

 - 索引条目通常远小于数据行大小，所以如果只需要读取索引，那mysql就会极大的减少数据访问量。
 - 因为索引是按照列值顺序存储的，所以对于I/O密集型范围查询回避随机从磁盘读取每一行数据的I/O要小的多
 - 由于Innodb的聚簇索引，覆盖索引对Innodb表特别有用，可以避免对主键索引的二次查询。

 覆盖索引的陷阱：
 ```
select * from products where actor = 'SEAN CARREY' and title like '%APOLLO%';
 ```
 - 没有索引能够覆盖这个查询，因为查询从表中选择了所有的列
 - mysql不能再索引中执行like操作，只能做最左前缀匹配

 #### 高性能索引-使用索引扫描来做排序

 mysql有两种方式可以生成有序的结果：通过排序操作；或者使用索引顺序扫描。mysql可以使用同一个索引既满足排序，有用于查找行。

只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向都一样时，mysql才能使用索引来对结果做排序。如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能用索引做排序。ORDER BY子句和查询的限制是一样的：需要满足索引的最左前缀的要求。

有一种情况下ORDER BY子句可以不满足索引的最左前缀要求：
```
 select rental_id, staff_id from sakila.rental where rental_date = '2005-05-25'
 order by inventory_id, customer_id;
```
索引为key(rental_date, inventory_id, customer_id)，前导列为常量的时候，如果where子句或者join子句中对这些列指定了常量，就可以弥补ORDER BY的不足。


```
 where rental_date > '2005-12-25' order by inventory_id, customer_id;
 where rental_date = '2005-12-25' and inventory_id in (1, 2) order by cusomter_id;
```

对于索引上是范围查询，mysql无法使用之后的索引列

#### 高性能索引-使用索引扫描减少锁

索引可以让查询锁定更少的行，如果你的查询从不访问那些不需要的行，那么就会锁定更少的行。但这只有当innoDB在存储引擎层能够过滤掉所有不需要的行是才有效。如果索引无法过滤掉无效的行，那么innoDB检索到数据并返回给服务器层后，innoDB已经锁定这些行了（mysql 5.6后没有这个问题）。

#### 高性能索引-避免多个范围条件

下面的查询：
```
where last_online > date_sub(now(), interval 7 day) and age bwtween 18 and 25
```
这个查询有一个问题：它有两个范围条件,last_online和age列，mysql可以使用last_online的索引或者是age列的索引，但是无法同时使用它们。

#### 高性能索引-延迟关联优化分页
如果一个查询匹配结果有上百万行的话会怎样？
```
select * from profiles where sex = 'm' order by rating limit 10;
```

即使有索引，如果用户界面需要翻页，并且翻页到比较靠后的地方也会非常慢，如：

```
select * from profiles where sex = 'm' order by rating limit 1000000, 10;
```

无论如何创建索引，这种查询都是个严重的问题，mysql需要花费大量时间来扫描需要丢弃的数据。其中一个解决的办法是限制能够翻页的数量。

优化这类索引的另一个比较好的策略是使用延迟关联，通过使用覆盖索引返回需要的主建，再根据这些主建回主表获得需要的行，这样可以减少mysql扫描需要丢弃的行数。

```
select * from profiles innner join 
(
    select id fomr profiles p where p.sex = 'm' order by rating limit 1000000, 10

) as t using (id);

```